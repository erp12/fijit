<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Guide to Fijit</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name"></span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="changelog.html"><div class="inner"><span>Changelog</span></div></a></li><li class="depth-1 "><a href="faq.html"><div class="inner"><span>FAQ</span></div></a></li><li class="depth-1  current"><a href="guide.html"><div class="inner"><span>Guide to Fijit</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>erp12</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>fijit</span></div></div></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>alpha</span></div></div></li><li class="depth-4"><a href="erp12.fijit.alpha.reflect.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>reflect</span></div></a></li><li class="depth-3 branch"><a href="erp12.fijit.collection.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>collection</span></div></a></li><li class="depth-3 branch"><a href="erp12.fijit.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="erp12.fijit.function.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>function</span></div></a></li><li class="depth-3 branch"><a href="erp12.fijit.option.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>option</span></div></a></li><li class="depth-3 branch"><a href="erp12.fijit.try.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>try</span></div></a></li><li class="depth-3 branch"><a href="erp12.fijit.tuple.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>tuple</span></div></a></li><li class="depth-3"><a href="erp12.fijit.version.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>version</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#guide-to-fijit" name="guide-to-fijit"></a>Guide to Fijit</h1>
<p>Clojure is a great language, but some people use Scala… and that’s okay!</p>
<h2><a href="#rationale" name="rationale"></a>Rationale</h2>
<p>Should you create a hybrid Clojure and Scala project? … probably not. Each language assumes a wildly different opinion on what makes an effective program.</p>
<p>What if you are <em>forced</em> to call out to a Scala project? Maybe you want to sneak some Clojure into your company’s Scala stack! Luckily, Clojure’s standard JVM interop features usually do a good job.</p>
<p>So what is the value of Fijit?</p>
<p><strong>Fijit makes interop easier by providing an idiomatic Clojure API into Scala constructs that commonly appear in Scala interfaces.</strong></p>
<p>In particular, Fijit was created to facilitate the development of idiomatic Clojure wrappers around the popular information processing frameworks that are available in Scala. For example, <a href="https://spark.apache.org/">Apache Spark</a> and <a href="https://akka.io/">Akka</a>. Clojure is a natural fit for these domains, but it can be difficult to leverage given the differences between Clojure and Scala (the host language of these frameworks). </p>
<p>In addition, Fijit provides some useful macros that leverage Clojure’s compile-on-load architecture to help you write code that targets multiple Scala versions. Scala is famous for having an interesting relationship with binary incompatibility [1] (which stands in stark contrast to Clojure :smile:) and it isn’t uncommon for  Scala projects to delay adding support for newer Scala versions for long periods of time. Fijit helps you  avoid these issues by allowing you to delegate to different implementations depending on which one is  supported by the version of Scala you are running.</p>
<h2><a href="#installation" name="installation"></a>Installation</h2>
<p>Fijit does not assume a specific Scala version, thus you must declare both Fijit and Scala as dependencies to your project. In particular, you need to depend on <code>scala-library</code>, <code>scala-reflect</code>, and <code>scala-compiler</code> all at the same version.</p>
<p>If we wanted to build our project against Scala 2.13.6 we would specify the following dependencies:</p>
<pre><code class="clojure">{:deps {io.github.erp12/fijit {:git/tag "1.0.7" :git/sha "5009b4d"}
        org.scala-lang/scala-library  {:mvn/version "2.13.6"}
        org.scala-lang/scala-reflect  {:mvn/version "2.13.6"}
        org.scala-lang/scala-compiler {:mvn/version "2.13.6"}}}
</code></pre>
<p>If we wanted to target multiple versions of Scala, we would use an alias for each version, and depend on fijit at the project level.</p>
<pre><code class="clojure">{:deps {io.github.erp12/fijit {:git/tag "1.0.7" :git/sha "5009b4d"}}
 :aliases {:2.12  {:extra-deps {org.scala-lang/scala-library  {:mvn/version "2.12.13"}
                                org.scala-lang/scala-reflect  {:mvn/version "2.12.13"}
                                org.scala-lang/scala-compiler {:mvn/version "2.12.13"}}}
           :2.13  {:extra-deps {org.scala-lang/scala-library  {:mvn/version "2.13.6"}
                                org.scala-lang/scala-reflect  {:mvn/version "2.13.6"}
                                org.scala-lang/scala-compiler {:mvn/version "2.13.6"}}}}}
</code></pre>
<p>We recommend declaring your fijit dependency with git coordinates. Releases are also published to Clojars. See the <a href="https://clojars.org/io.github.erp12/fijit">fijit Clojars page</a> for more details. </p>
<h2><a href="#usage-overview" name="usage-overview"></a>Usage Overview</h2>
<p>The following sections will demonstrate some core features provided by fijit. For the complete API, see <a href="https://erp12.github.io/fijit/">the documentation site</a>.</p>
<h3><a href="#collections" name="collections"></a>Collections</h3>
<p>Using the <code>erp12.fijit.collection</code> namespace, Scala collections can be created with <code>scala-*</code> functions. These functions mirror their Clojure counterparts.</p>
<blockquote>
  <p>Note: Exact return types may change depending on your Scala version.</p>
</blockquote>
<pre><code class="clojure">(use 'erp12.fijit.collection)

(scala-list :a :b)
; =&gt; #object[scala.collection.immutable.$colon$colon 0x58acad38 "List(:a, :b)"]

(scala-vector :a :b)
; =&gt; #object[scala.collection.immutable.Vector1 0x27571648 "Vector(:a, :b)"]

(scala-set :a :b :a)
; =&gt; #object[scala.collection.immutable.Set$Set2 0x40104fb7 "Set(:a, :b)"]

(scala-map :a 1
           :b 2
           :c 3)
; =&gt; #object[scala.collection.convert.JavaCollectionWrappers$JMapWrapper 0x28a5f7e1 "Map(:a -&gt; 1, :b -&gt; 2, :c -&gt; 3)"]
</code></pre>
<p>Clojure collections can be converted to Scala collections using the <code>to-scala-*</code> functions. Many of these functions are flexible with respect to the exact collection type passed as input.</p>
<pre><code class="clojure">(to-scala-list [:a :b])
; =&gt; #object[scala.collection.immutable.$colon$colon 0x1320cfab "List(:a, :b)"]

(to-scala-vector [:a :b])
; =&gt; #object[scala.collection.immutable.Vector1 0x54816c33 "Vector(:a, :b)"]

(to-scala-set #{1 1 1})
; =&gt; #object[scala.collection.immutable.Set$Set1 0x48b97f32 "Set(:a)"]

(to-scala-map {:a 1 :b 2})
; =&gt; #object[scala.collection.convert.JavaCollectionWrappers$JMapWrapper 0x64be80db "Map(:a -&gt; 1, :b -&gt; 2)"]
</code></pre>
<p>Scala collections can be converted to Clojure collections. These functions mostly assume that the type of the collection is compatible with the collection type mentioned in the function name. For example, the <code>map-&gt;clj</code> function expects to be passed an instance of <code>scala.collection.Map</code>.</p>
<pre><code class="clojure">(seq-&gt;clj (scala-seq :a :b))
; =&gt; (:a :b)

(vector-&gt;clj (scala-vector :a :b))
; =&gt; [:a :b]

(set-&gt;clj (scala-set :a :b))
; =&gt; #{:b :a}

(map-&gt;clj (scala-map :a 1 :b 2))
; =&gt; {:a 1, :b 2}
</code></pre>
<p>In some scenarios, there is no need to be explicit about the collection type we want to create, but rather we would like the logical collection type for the other host language. This is more commonly the case when converting Scala collections to Clojure collections. </p>
<p>In these cases, the <code>-&gt;clj</code> and <code>-&gt;scala</code> functions can be used to generically convert collections using a logically associated types. For example, Scala vectors to Clojure vectors and Scala maps to Clojure maps.</p>
<p>These mappings are not applies recursively because this could result in significant extra work in scenarios where the inner collections are intended to be passed back to an abstraction written in their types host language. For example, if we have a Scala <code>Seq[Map[String,Int]]</code> and would like to write a some Clojure code that passed each <code>Map</code> to a Scala function, only the outer <code>Seq</code> should be converted to a Clojure collection.</p>
<h3><a href="#functions" name="functions"></a>Functions</h3>
<p>Scala provides a different interface (trait) for function types of each arity. For example, a function that takes 1 parameters will implement <code>scala.Function1</code>. Fijit provides a suite of <code>deftype</code> that implement Scala’s function interfaces, as well as <code>java.io.Serializable</code> and <code>clojure.lang.IFn</code>. These types simply wrap a Clojure function that is assumed to have the same arity as the desired Scala function type. These types can be constructed useing the <code>-&gt;fn*</code> functions.</p>
<pre><code class="clojure">(require '[erp12.fijit.function :as sf])

(def add-one 
  (sf/-&gt;fn1 #(+ 1 %))) 

add-one
; =&gt;  #object[erp12.fijit.function.Function1 0x29429270 "erp12.fijit.function.Function1@29429270"]

(instance? scala.Function1 add-one)
; =&gt; true

; Invoked as a Scala function.
(.apply add-one 10) ; =&gt; 11

; Invoked as a Clojure function.
(add-one 10) ; =&gt; 11 

(def bad-fn2
  ; The `identity` function takes 1 parameter, but we are building a `scala.Function2`.
  (sf/-&gt;fn2 identity))

; The bad-fn2 is creatable...
bad-fn2
; =&gt; #object[erp12.fijit.function.Function2 0x67539f2 "erp12.fijit.function.Function2@67539f2"]

; ... but it cannot be invoked.
(.apply bad-fn2 :A) ; throws IllegalArgumentException
(bad-fn2 :A) ; throws AbstractMethodError
</code></pre>
<p>Fijit also provides a macro for declaring Scala functions that will implicitly create a Clojure funciton and wrap it in the correct fijit funciton wrapper. The <code>scala-fn</code> macro can be called very similarly to the Clojure core <code>fn</code> macro.</p>
<pre><code class="clojure">(def plus (sf/scala-fn [a b] (+ a b)))

(instance? scala.Function2 plus)
; =&gt; true

; Invoked as a Scala function.
(.apply plus 1 2) ; =&gt; 3

; Invoked as a Clojure function.
(plus 1 2) ; =&gt; 3
</code></pre>
<h3><a href="#option-and-try" name="option-and-try"></a>Option and Try</h3>
<p>Scala represents optional values with the wrapper type <code>scala.Option</code>. Many Scala interfaces require <code>Option</code> objects as input and provide <code>Option</code> objects as returned values.</p>
<p>The object for non-existing values (<code>scala.None</code>) is a singleton. Fijit provides this as a <code>def</code>.</p>
<pre><code class="clojure">(use 'erp12.fijit.option)

none
;=&gt; #object[scala.None$ 0x14e04246 "None"]
</code></pre>
<p>Creating <code>Option</code>s can be done with <code>option</code> function. If provided <code>nil</code> or no arguments, it will return <code>None</code>. Otherwise it will return a <code>Some</code> that wrapps the given value.</p>
<pre><code class="clojure">(option)
; =&gt; #object[scala.None$ 0x14e04246 "None"]

(option nil)
; =&gt; #object[scala.None$ 0x14e04246 "None"]

(option :A)
; =&gt; #object[scala.Some 0x6e742b26 "Some(:A)"]
</code></pre>
<p>Fijit also provides a variety of ways to handle <code>Option</code> values in our Clojure projects. The <code>emtpy?</code> and <code>defined?</code> predicates can be used check if the <code>Option</code> is holding a value. </p>
<pre><code class="clojure">(require '[erp12.fijit.option :as opt])

(opt/empty? opt/none) ; =&gt; true
(opt/empty? (opt/option :A)) ; =&gt; false

(opt/defined? opt/none) ; =&gt; false
(opt/defined? (opt/option :A)) ; =&gt; true
</code></pre>
<p>Option objects can be unpacked with the <code>get</code> macro. If not passed an <code>or-else</code> form, a <code>NoSuchElementException</code> will be thrown. </p>
<pre><code class="clojure">(opt/get (opt/option :A)) ; =&gt; :A
(opt/get none) ; throws NoSuchElementException
(opt/get none :not-found) ; =&gt; :not-found
</code></pre>
<p>Side effects and custom error handling can be implemented in the <code>or-else</code> form of the <code>get</code> macro because it will not be evaluated unless the option is empty.</p>
<pre><code class="clojure">(opt/get opt/none (throw (ex-info "Oh no!" {}))) ; throws ExceptionInfo
</code></pre>
<p>The idiomatic Clojure representation of a missing value is <code>nil</code>, thus it is common to unpack options into their held value or <code>nil</code> if the option is <code>None</code>. Fijit provides a function with this behavior. </p>
<pre><code class="clojure">(opt/get-or-nil (opt/option :A)) ; =&gt; :A
(opt/get-or-nil opt/none) ; =&gt; nil
</code></pre>
<h3><a href="#try" name="try"></a>Try</h3>
<p>The Scala <code>Try</code> type represents the result of a computation that either raised an exception, or successfully returned a computed value. </p>
<p>We can create <code>Try</code> objects using the <code>scala-try</code> macro.</p>
<pre><code class="clojure">(require '[erp12.fijit.try :as t])

(t/scala-try (/ 4 2))
; =&gt; #object[scala.util.Success 0x5c1bfc1c "Success(2)"]

(t/scala-try (/ 4 0))
; =&gt; #object[scala.util.Failure 0x1488471 "Failure(java.lang.ArithmeticException: Divide by zero)"]
</code></pre>
<p>The <code>failure?</code> and <code>success?</code> predicates can be used check if a <code>Try</code> is representing a raised exception or a successfully computed value.</p>
<pre><code class="clojure">(t/failure? (t/scala-try (/ 4 2))) ; =&gt; false
(t/failure? (t/scala-ty (/ 4 0))) ; =&gt; true

(t/success? (t/scala-try (/ 4 2))) ; =&gt; true
(t/success? (t/scala-ty (/ 4 0))) ; =&gt; false
</code></pre>
<p>Try objects can be unpacked with the <code>get</code> macro (different from the <code>get</code> macro in other fijit namespaces).</p>
<p>If no <code>or-else</code> form is provided and the <code>Try</code> is a <code>Failure</code>, the exception held by the try will be thrown. If an <code>or-else</code> is provided, it will be evaluated in the event the that try is a <code>Failure</code> instead of raising the exception. Some use cases for this behavior include: throwing a more specific error or performing a “retry”.</p>
<pre><code class="clojure">(t/get (t/scala-try (/ 4 2))) ; =&gt; 2
(t/get (t/scala-try (/ 4 0))) ; throws ArithmeticException
(t/get (t/scala-try (/ 4 0)) 0) ; =&gt; 0

(defn my-div
  [n d] 
  (t/get (t/scala-try (/ n d)) 
         (throw (ex-info "Failed division!" {:numerator n :denominator d}))))

(my-div 3 0) ; throws clojure.lang.ExceptionInfo: Failed division! {:numerator 3, :denominator 0}
</code></pre>
<h3><a href="#tuple" name="tuple"></a>Tuple</h3>
<p>Tuples are the canonical representation of Scala <code>Product</code> types. Scala uses a different type to denote a scala of each size. For exaple, 2 element tuples are represented as instances of <code>Tuple2</code>.</p>
<p>We can create Scala tuples with fijit in a couple ways. The first is the <code>scala-tuple</code> function, which will accept a variable number of elements and return a Scala tuple. The second is the <code>to-tuple</code> function, which will converts a sequential Clojure collection to a tuple.</p>
<pre><code class="clojure">(require '[erp12.fijit.tuple :as tup])

(tup/scala-tuple :a 1)
; =&gt; #object[scala.Tuple2 0x4fc03728 "(:a,1)"]

(tup/scala-tuple :a)
; =&gt; #object[scala.Tuple1 0x5dbab3c5 "(:a)"]

(tup/to-tuple [:a 1])
; =&gt; #object[scala.Tuple2 0x6c62f09e "(:a,1)"]
</code></pre>
<p>Scala tuples can be converted to a Clojure vector using the <code>product-&gt;vec</code> function. This function can be used on any product, including instances of case classes.</p>
<pre><code class="clojure">(tup/product-&gt;vec (tup/scala-tuple :a 1)) 
; =&gt; [:a 1]
</code></pre>
<h3><a href="#targeting-multiple-scala-versions" name="targeting-multiple-scala-versions"></a>Targeting multiple Scala versions</h3>
<p>Fijit helps us write Clojure code that safely runs on top multiple Scala versions!</p>
<p>First, it can be helpful to know at runtime which exact version of Scala we are running. The <code>scala-version</code> symbol will provide a map of version-parts and their numeric value.</p>
<pre><code class="clojure">(require '[erp12.fijit.version :as sv])

sv/scala-version
; =&gt; {:major 2, :minor 13, :patch 6}
</code></pre>
<p>More importantly, the <code>by-scala-version</code> macro will deligate to a different form depending on the Scala version. We can supply pairs of scala versions and their implementations and let Clojure’s compile-on-load architecture sort out how to compile the byte code.</p>
<p>Consider the following Clojure code:</p>
<pre><code class="clojure">(sv/by-scala-version :2.12    :A
                     :2.12.10 :B
                     :2.13.4  :C)
</code></pre>
<p>The behavior will be different depending on the Scala version. Specifically the above code will…</p>
<ul>
  <li>Return <code>:A</code> on Scala 2.12.0 through 2.13.9.</li>
  <li>Return <code>:B</code> for :2.12.10 and all other 2.12.x versions.</li>
  <li>Throw and exception for scala 2.13.0 through 2.13.3.</li>
  <li>Return <code>:C</code> for 2.13.4 and all other 2.13.x versions.</li>
</ul>
<p>In other words, the form that corresponds to the highest compatible version will be executed. A compatible version is one that has the same major and minor versions as the current version of Scala on the classpath. If a form’s version keyword contains a patch version, it will only be valid if the patch version of the active Scala version is at least the same number.</p>
<hr />
<p>[1] Want to read more about Scala and binary incompatibility? There are some official docs on the subject  <a href="https://docs.scala-lang.org/overviews/core/binary-compatibility-for-library-authors.html">here</a> and  <a href="https://docs.scala-lang.org/overviews/core/binary-compatibility-of-scala-releases.html">here</a>.  The Apache Spark project has also served as a good example of how difficult upgrading to a new minor version  (or supporting multiple minor versions) can be. See <a href="https://contributors.scala-lang.org/t/spark-as-a-scala-gateway-drug-and-the-2-12-failure/1747">this discussion</a>  about migrating from 2.11 to 2.12 as well as <a href="https://issues.apache.org/jira/browse/SPARK-25075">this ticket</a>  about making Spark compatible with 2.13.</p></div></div></div></body></html>